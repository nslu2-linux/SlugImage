#!/usr/bin/perl
# 
# SlugImage : Manipulate NSLU2 firmware images
#             Dwayne Fontenot (jacques)
#             Rod Whitby (rwhitby)
#	      www.nslu2-linux.org
#
# Copyright (c) 2004, Dwayne Fontenot & Rod Whitby
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
# Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# Neither the name of the NSLU2-Linux Development Team nor the names
# of its contributors may be used to endorse or promote products
# derived from this software without specific prior written
# permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

use strict;
use warnings;

use Getopt::Long;

my($debug) = 0;
my($quiet) = 0;

# Take $data, and pad it out to $total_len bytes, appending 0xff's.
sub padBytes {
    my($data,$total_len) = @_;

    my($pad_char) = pack("C",0xff);
    my($pad_len) = $total_len - length($data);

    if (length($data) > $total_len) {
	die "padBytes error: data is longer than total_len";
    }

    return $data . ($pad_char x $pad_len);
}

# Return the next multiple of block_size larger than or equal to $data_len.
sub paddedSize {
    my($data_len) = @_;

    my($block_size) = 0x00020000;
    use integer;
    return (($data_len - 1) / $block_size) * $block_size + $block_size;
}

# Return the number of block_size blocks required to hold $data_len.
sub numBlocks {
    my($data_len) = @_;

    my($block_size) = 0x00020000;
    use integer;
    return (($data_len - 1) / $block_size) + 1;
}

# Pack the name, address, and size of a partition entry into binary form.
sub createPartitionEntry {
    my($name, $flash_base, $size) = @_;

    my($zero_long) = 0x0000;

    $debug and printf("createPartitionEntry: %s\t0x%08X\t0x%08X\t%d\n", $name, $flash_base, $size, $size / 0x00020000);

    return pack("a16N5x212N2",$name,$flash_base,$zero_long,$size,$zero_long,$zero_long,$zero_long,$zero_long);
}

# parse partition entry and return anon array ref [$name, $offset, $size] or return 0 on partition terminator
sub parsePartitionEntry {
    my($partition_entry) = @_;

    my($flash_start) = 0x50000000;
    my($entry_len) = 0x100;
    length($partition_entry) eq $entry_len or die "parsePartitionEntry: partition entry length is not $entry_len!\n";

    my($name, $flash_base, $size, $zero_long, $padding);
    ($name, $flash_base, $zero_long, $size, $zero_long, $zero_long, $padding, $zero_long, $zero_long) =
	unpack("a16N5x212N2",$partition_entry);

    if(unpack("C", $name) eq 0xff){
	$debug and print "parsePartitionEntry: found terminator\n";
	return 0;
    }
    # remove trailing nulls from $name
    $name =~ s/\000+//;
    return [$name, $flash_base - $flash_start, $size];
}

# return partition table from data is one exists, otherwise return 0
sub findPartitionTable {
    my($data_buf) = @_;

    unpack("a7", $data_buf) eq 'RedBoot' or return 0;
    return substr($data_buf, 0, 0x1000)
}

# parse partition table and return array of anonymous array references ([$name, $offset, $size], ...)
sub parsePartitionTable {
    my($partition_table) = @_;

    my(@partitions, $fields_ref);
    my($entry_len) = 0x100;
    my($partition_count) = 0;
    while ($fields_ref = parsePartitionEntry(substr($partition_table, $partition_count * $entry_len, $entry_len))){
	$debug and printf("parsePartitionTable: %s\t0x%08X\t0x%08X\n", @$fields_ref);
	$partitions[$partition_count++] = $fields_ref;
    }
    return(@partitions);
}

# Create an empty jffs2 block.
sub jffs2Block {
    return padBytes(pack("N3", 0x19852003, 0x0000000c, 0xf060dc98), 0x00020000);
}

# Write out $data to $filename,
sub writeOut {
    my($data, $filename) = @_;

    open FILE,">$filename" or die "Can't open file \"$filename\": $!\n";

    if(defined($data)){ print FILE $data;}

    close FILE or die "Can't close file \"$filename\": $!\n";
}

# Not used at the moment.
sub trailerData {
    my($product_id)       = 0x0001;
    my($protocol_id)      = 0x0000;
    my($firmware_version) = 0x2325;
    my($unknown1)         = 0x90f7;
    my($magic_number)     = 'eRcOmM';
    my($unknown2)         = 0x00b9;

    return pack("n4a6n",$product_id,$protocol_id,$firmware_version,$unknown1,$magic_number,$unknown2);
}

# print contents of sercomm redboot trailer
sub printRedbootTrailer {
    my($redboot_data) = @_;

    my($correct_redboot_len) = 0x40000;
    my($redboot_data_len) = length($redboot_data);

    if($redboot_data_len != $correct_redboot_len){
	printf("Redboot length (0x%08X) is not 0x%08X\n", $redboot_data_len, $correct_redboot_len);
	return;
    }

    my($redboot_trailer) = substr($redboot_data, -80);

    writeOut($redboot_trailer, 'RedbootTrailer');

    my($mac_addr0, $mac_addr1, $mac_addr2, $unknown, $prefix, $ver_ctrl, $down_ctrl, $hid, $hver, $prodid, $prodidmask,
       $protid, $protidmask, $funcid, $funcidmask, $fver, $cseg, $csize, $postfix) =
	   unpack("n3Na7n2a32n10a7",$redboot_trailer);

    printf("MAC address is %04X%04X%04X\n", $mac_addr0, $mac_addr1, $mac_addr2);
    printf("unknown: %08X\n", $unknown);
    printf("%s:%04X:%04X:%s\n", $prefix, $ver_ctrl, $down_ctrl, $postfix);
    printf("VerControl: %04X\nDownControl: %04X\n", $ver_ctrl, $down_ctrl);
    printf("hid: %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X\n", unpack("n16", $hid));
    printf("Hver: %04X\nProdID: %04X\nProtID: %04X\nFuncID: %04X\nFver: %04X\nCseg: %04X\nCsize: %04X\n",
	   $hver, $prodid, $protid, $funcid, $fver, $cseg, $csize);
}

# populate @partitions based on the default partition table
sub useDefaultPartitions {
    my($firmware_buf, $partitions_ref) = @_;

    $debug and print 'useDefaultPartitions: ',length($firmware_buf),' ', scalar(@$partitions_ref),"\n";

    # Read the parts of the firmware file into the partitions table.
    map {
	if (defined $_->{'offset'} and defined $_->{'size'}) {

	    # Grab the whole partition, using the maximum size.
	    $_->{'data'} = substr($firmware_buf, $_->{'offset'}, $_->{'size'});

	    # Handle those partitions which can be smaller.
	    if (($_->{'name'} eq 'Kernel') or ($_->{'name'} eq 'Ramdisk')) {

		# Read the length, remove it from the start of the data, and
		# truncate the data according to the length.
		my $size = unpack("N", $_->{'data'});
		$_->{'data'} = substr($_->{'data'}, 16, $size);

		# Size the Ramdisk partition to the next block boundary.
		if ($_->{'name'} eq 'Ramdisk') {
		    $_->{'size'} = paddedSize($size);
		}
	    }
	    $quiet or printf("Read 0x%08X bytes into <%s>\n", length($_->{'data'}), $_->{'name'});
	}
    } @$partitions_ref;
}

# populate @partitions based on the firmware's partition table
sub useFirmwarePartitions {
    my($firmware_buf, $partitions_ref) = @_;

    $debug and print 'useFirmwarePartitions: ',length($firmware_buf),' ', scalar(@$partitions_ref),"\n";

    # we know that partition table, if it exists, begins at start of 'FIS directory' and has max length 0x1000
    my($partition_table);
    map {
	$_->{'name'} eq 'FIS directory' and
	    $partition_table = findPartitionTable(substr($firmware_buf, $_->{'offset'}, $_->{'size'}));
    } @$partitions_ref;

    # return 0 here if no partition table in FIS directory
    return 0 if not $partition_table;

    # don't want any default partitions hanging around
    @$partitions_ref = ();

    my($partition_count) = 0;
    map {
	$debug and printf("%s\t0x%08X\t0x%08X\n", @$_);
	$partitions_ref->[$partition_count] = {'name'=>$_->[0], 'offset'=>$_->[1], 'size'=>$_->[2], 'file'=>$_->[0]};
	if($_->[0] eq 'Kernel' or $_->[0] eq 'Ramdisk'){
	    my($data_len) =  unpack("N", substr($firmware_buf, $_->[1]));
	    $debug and printf("%s has data length 0x%08X\n",$partitions_ref->[$partition_count]->{'name'} , $data_len);
	    $partitions_ref->[$partition_count]->{'data'}   = substr($firmware_buf, $_->[1] + 16, $data_len);
	}
	else {
	    $partitions_ref->[$partition_count]->{'data'}   = substr($firmware_buf, $_->[1], $_->[2]);
	}
	$partition_count++;
    } parsePartitionTable($partition_table);

    # need to add Trailer entry?

    return 1;
}

# Read in an 8MB firmware file, and store the data into @partitions.
# Note that the data is only stored in a partition if 'offset' and 'size' are defined. (fix this comment)
sub readInFirmware {
    my($filename, $partitions_ref) = @_;

    my($firmware_buf);
    my($total_length)   = 0x800000;

    open FILE,$filename or die "Can't find firmware image \"$filename\": $!\n";
    read FILE,$firmware_buf,$total_length or die "Can't read $total_length bytes from \"$filename\": $!\n";
    close FILE or die "Can't close \"$filename\": $!\n";

    useFirmwarePartitions($firmware_buf, $partitions_ref) or useDefaultPartitions($firmware_buf, $partitions_ref);
}

# Write the partition data stored in memory out into the files associated with each.
sub writeOutFirmwareParts {
    my(@partitions) = @_;

    # Write out the parts of the firmware file.
    map {

	# We can only write if 'data' and 'file' are defined.
	if (defined $_->{'data'} and defined $_->{'file'}) {
	    writeOut($_->{'data'}, $_->{'file'});
	    $quiet or printf("Wrote 0x%08X bytes from <%s> into \"%s\"\n",
			      length($_->{'data'}), $_->{'name'}, $_->{'file'});
	}
	else {
	    $quiet or print "Skipping ", $_->{'name'}, "\n";
	}

    } @partitions;

    return;
}

# Read in the partition data from the files associated with each and store in memory.
sub readInFirmwareParts {
    my(@partitions) = (@_);
    
    undef $/; # we want to slurp

    map {

	my $file = $_->{'file'};
	if (defined $file) {
	    open FILE,$file or die "Can't find firmware part \"$file\": $!\n";

	    # Slurp in the data
	    $_->{'data'} = <FILE>;

	    # close the file
	    close FILE or die "Can't close file \"$file\": $!\n";

	    # Keep track of the actual size.
	    my $size;

	    # For the Ramdisk, we need to account for the length header.
	    if ($_->{'name'} eq 'Ramdisk') {
		$size = paddedSize(16 + length($_->{'data'}));
	    }
	    else {
		$size = paddedSize(length($_->{'data'}));
	    }

	    # If the partition does not have a fixed size, the calculate the size.
	    if (not defined $_->{'size'}) {
		$_->{'size'} = $size;
	    }

	    # Keep the user appraised ...
	    $quiet or printf("Read 0x%08X bytes from \"%s\" into <%s> (%d blocks)\n",
			      length($_->{'data'}), $_->{'file'}, $_->{'name'}, numBlocks($size));
	}
	else {
	    # read in payload if defined
	    if($_->{'name'} eq 'FIS directory' and defined $_->{'payload'}){
		my($payload) = $_->{'payload'};
		open PAYLOAD,$payload or die "Can't find payload \"$payload\": $!\n";
		$_->{'payload_data'} = <PAYLOAD>;
		close PAYLOAD or die "Can't close file \"$payload\": $!\n";
		$quiet or printf("Read 0x%08X bytes of payload data from \"$payload\"\n", length($_->{'payload_data'}));
	    }
	}

    } @partitions;

    return;
}

# layoutPartitions : this function must be ugly - it needs to verify RedBoot, SysConf, Kernel, Ramdisk, and
#     FIS directory partitions exist, are in the correct order, and do not have more data than can fit in
#     their lengths (fixed for all but Ramdisk, which has a minimum length of one block).
#     If Rootdisk and/or Userdisk exist, it must also verify that their block padded lengths are not
#     too great for the available space.
# input : an array of hashes, some of which are populated with data
# output: same reference with start and size (partition not data) also populated. this populated structure
#         can then be passed to buildPartitionTable() to generate the actual partition table data
sub layoutPartitions {
    my(@partitions) = @_;

    my($flash_start) = 0x50000000;
    my($flash_len)   = 0x00800000;
    my($block_size)  = 0x00020000;

    #
    # here we go through the $partitions array ref and fill in all the values
    #

    # This points to where the next partition should be placed.
    my $pointer = $flash_start;

    map {

	# If this is the last variable size partition, then fill the rest of the space.
	if ($_->{'name'} eq $partitions[-3]->{'name'}) {
	    $_->{'size'} = paddedSize($partitions[-2]->{'offset'} + $flash_start - $pointer);
	}

	# Handle requests for partition creation first.
	if (defined $_->{'size'} and not defined $_->{'data'} and ($_->{'name'} ne "FIS directory")) {

	    # A zero size is a request to fill all available space.
	    if ($_->{'size'} == 0) {
		# Grab the start of the FIS directory, and use all the space up to there.
		$_->{'size'} = paddedSize($partitions[-2]->{'offset'} + $flash_start - $pointer);
	    }

	    # Create an empty partition of the requested size.
	    $_->{'data'} = padBytes("", $_->{'size'});

	    # Check to make sure that the requested size is not too large.
	    if (($pointer + $_->{'size'}) > ($flash_start + $partitions[-2]->{'offset'})) {
		die "Ran out of flash space in <", $_->{'name'}, ">\n";
	    }

	    # Keep the user appraised ...
	    $quiet or printf("Created <%s> (%d blocks)\n", $_->{'name'}, $_->{'size'});
	}

	# The handle known partitions, and allocate them.
	if (defined $_->{'size'} and ($_->{'name'} ne "Trailer")) {

	    # Determine the start and offset of the current partition.
	    if (defined $_->{'offset'}) {
		$_->{'start'} = $flash_start + $_->{'offset'};

		# Keep the user appraised ...
		$quiet or printf("Allocated <%s> from 0x%08X to 0x%08X (%d blocks)\n",
				  $_->{'name'}, $_->{'start'}, $_->{'start'} + $_->{'size'}, numBlocks($_->{'size'}));
	    }

	    # If offset is not defined, then calculate it.
	    else {
		$_->{'start'} = $pointer;
		$_->{'offset'} = $_->{'start'} - $flash_start;

		# Keep the user appraised ...
		$quiet or printf("Allocated <%s> from 0x%08X to 0x%08X (%d blocks)\n",
				  $_->{'name'}, $_->{'start'}, $_->{'start'} + $_->{'size'}, numBlocks($_->{'size'}));
	    }

	    # Check to make sure we have not run out of room.
	    if (($_->{'start'} + $_->{'size'}) > ($flash_start + $flash_len)) {
		die "Ran out of flash space in <", $_->{'name'}, ">\n";
	    }

	    # Move the pointer up, in preparation for the next partition.
	    $pointer = $_->{'start'} + paddedSize($_->{'size'});

	}

    } @partitions;

    return;
}

sub buildPartitionTable {
    my(@partitions) = @_;

    my($flash_start) = 0x50000000;
    my($payload_offset) = 0x1000;
    my($partition_data) = '';

    map {

	# Collate the partition data for all known partitions.
	if (defined $_->{'offset'} and defined $_->{'size'}) {

	    # Pack and append the binary table entry for this partition.
	    $partition_data .= createPartitionEntry($_->{'name'}, $_->{'offset'} + $flash_start, $_->{'size'});

	    # If this is the FIS directory, then write the partition table data into it.
	    if ($_->{'name'} eq "FIS directory") {
		# Explicitly terminate the partition data.
		$partition_data .= pack("C",0xff) x 0x100;
		if(defined $_->{'payload_data'}){
		    $_->{'data'} = padBytes($partition_data, $payload_offset) .
			padBytes(pack("N4",length($_->{'payload_data'})).$_->{'payload_data'},
				 $_->{'size'} - $payload_offset);
		    $quiet or printf("Inserted 0x%08X bytes of payload data into <FIS directory>\n",
				     length($_->{'payload_data'}));
		}
		else {
		    $_->{'data'} = padBytes($partition_data, $_->{'size'});
		}
	    }
	}
	else {
	    $quiet or print "Skipping ", $_->{'name'}, "\n";
	}

    } @partitions;

    return;
}

# checkPartitionTable: sanity check partition table - for testing but might evolve into setting @partitions
#    so that we can write out jffs2 partitions from a read image
#    currently not nearly paranoid enough
sub checkPartitionTable {
    my($data) = @_;

    my($zero_long) = 0x0000;


    my($pointer) = 0;
    my($entry);

    my($name, $flash_base, $size, $done, $padding);
    do {
	$entry = substr($data, $pointer, 0x100);

	($name,$flash_base,$zero_long,$size,$zero_long,$zero_long,$padding,$zero_long,$zero_long) = unpack("a16N5x212N2",$entry);
	$debug and printf("pointer: %d\tname: %s\tflash_base: 0x%08X\tsize: 0x%08X\n", $pointer, $name, $flash_base, $size);
	$pointer += 0x100;
	$debug and printf("terminator: 0x%08X\n", unpack("C", substr($data, $pointer, 1)));
	if(unpack("C", substr($data, $pointer, 1)) eq 0xff){
	    $done = 1;
	}
    } until $done;
}


sub writeOutFirmware {
    my($filename, @partitions) = @_;

    my $image_buf = "";

    map {

	if (defined $_->{'offset'} and defined $_->{'size'} and defined $_->{'data'}) {

	    my $pointer = length($image_buf);

	    if ($_->{'offset'} > $pointer) {
		$image_buf .= padBytes("", $_->{'offset'} - $pointer);
		$quiet or printf("Padded %d blocks before <%s> in \"%s\"\n",
				  numBlocks(length($image_buf) - $pointer), $_->{'name'}, $filename);
		$pointer = length($image_buf);
	    }
	    elsif ($_->{'offset'} < $pointer) {
		$image_buf = substr($image_buf, 0, $_->{'offset'});
		$quiet or printf("Rewound %d bytes before <%s> in \"%s\"\n",
				  $pointer - $_->{'offset'}, $_->{'name'}, $filename);
		$pointer = length($image_buf);
	    }

	    if ($_->{'name'} eq "Kernel") {
		$image_buf .= padBytes(pack("N4",length($_->{'data'})).$_->{'data'},
				       $_->{'size'});
	    }
	    elsif ($_->{'name'} eq "Ramdisk") {
		$image_buf .= padBytes(pack("N4",length($_->{'data'})).$_->{'data'},
				       $_->{'size'});
	    }
	    elsif ($_->{'name'} eq "Trailer") {
		$image_buf .= $_->{'data'};
	    }
	    else {
		$image_buf .= padBytes($_->{'data'}, $_->{'size'});
	    }
	    
	    if ($_->{'name'} eq 'Trailer') {
		$quiet or printf("Wrote %d bytes (0x%08X to 0x%08X) from <%s> into \"%s\"\n",
				  length($image_buf) - $pointer, $pointer, length($image_buf), $_->{'name'}, $filename);
	    }
	    else {
		$quiet or printf("Wrote %d blocks (0x%08X to 0x%08X) from <%s> into \"%s\"\n",
				  numBlocks(length($image_buf) - $pointer), $pointer, length($image_buf),
				  $_->{'name'}, $filename);
	    }
	}
	else {
	    $quiet or print "Skipping ", $_->{'name'}, "\n";
	}

    } @partitions;

    writeOut($image_buf, $filename);

    return;
}


sub printPartitions {
    my(@partitions) = @_;

    my($offset, $size);
    map {
#	defined $_->{'size'} ? $size = $_->{'size'} : $size = 'undef';

	if(defined  $_->{'size'}){
	    $size = $_->{'size'};
	}
	else {
	    $size = 'undef';
	}
	if(defined  $_->{'offset'}){
	    $offset = $_->{'offset'};
	}
	else {
	    $offset = 'undef';
	}
	printf("%s\t0x%08X\t0x%08X\n", $_->{'name'}, $offset, $size);
    } @partitions;
}

sub defaultPartitions {

    # Note that other routines make assumptions that this table will stay in the current order, with
    # new partitions only being added where the current Ramdisk partition exists.
    # In particular, the Ramdisk partition must stay at index 3, and the partition at the end of the
    # Ramdisk/Rootdisk/Userdis partitions must stay at index -2.

    return ({'name'=>'RedBoot',      'file'=>'Redboot',   'offset'=>0x00000000,'size'=>0x00040000,'data'=>undef},
	    {'name'=>'SysConf',      'file'=>'SysConf',   'offset'=>0x00040000,'size'=>0x00020000,'data'=>undef},
	    {'name'=>'Kernel',       'file'=>'vmlinuz',   'offset'=>0x00060000,'size'=>0x00100000,'data'=>undef},
	    {'name'=>'Ramdisk',      'file'=>'ramdisk.gz','offset'=>0x00160000,'size'=>0x00680000,'data'=>undef},
	    {'name'=>'FIS directory','file'=>undef,       'offset'=>0x007e0000,'size'=>0x00020000,'data'=>undef},
	    {'name'=>'Trailer',      'file'=>'Trailer',   'offset'=>0x007ffff0,'size'=>0x00000010,'data'=>undef},
	    );

}

#
# flow should go something like this:
# call @partitions = defaultPartitions(), populate filenames with command line args
# pass \@partitions to some func which reads the files and populates the data values
# pass \@partitions to layoutPartitions() to get fully populated (start and size values)
# some func, possibly layoutPartitions() needs to call padBytes() on the various partition data
# with the correct size value (which should have been calculated by layoutPartitions() with the
# help of fixed partition lengths and for variable length partitions, paddedSize()
# then write out the image, somewhere in there passing \@partitions to lastBlock() which in turn
# passes it to buildPartitionTable (which should be renamed to partitionTable and replace it)
#

my(@partitions) = defaultPartitions();

my($unpack, $pack, $input, $output, $redboot, $kernel, $sysconf, $ramdisk, $fisdir, $trailer, $macaddr, $payload);

if (!GetOptions("d|debug"      => \$debug,
		"q|quiet"      => \$quiet,
		"u|unpack"     => \$unpack,
		"p|pack"       => \$pack,
		"i|input=s"    => \$input,
		"o|output=s"   => \$output,
		"b|redboot=s"  => \$redboot,
		"k|kernel=s"   => \$kernel,
		"s|sysconf=s"  => \$sysconf,
		"r|ramdisk=s"  => \$ramdisk,
		"f|fisdir=s"   => \$fisdir,
		"t|trailer=s"  => \$trailer,
		"m|macaddr=s"  => \$macaddr,
		"l|payload=s"  => \$payload,
		) or (not defined $pack and not defined $unpack)) {
    print "Usage: slugimage <options>\n";
    print "\n";
    print "  [-d|--debug]			Turn on debugging output\n";
    print "  [-q|--quiet]			Turn off status messages\n";
    print "  [-u|--unpack]			Unpack a firmware image\n";
    print "  [-p|--pack]			Pack a firmware image\n";
    print "  [-i|--input]    <file>		Input firmware image filename\n";
    print "  [-o|--output]   <file>		Output firmware image filename\n";
    print "  [-b|--redboot]  <file>		Input/Output RedBoot filename\n";
    print "  [-k|--kernel]   <file>		Input/Ouptut Kernel filename\n";
    print "  [-s|--sysconf]  <file>		Input/Output SysConf filename\n";
    print "  [-r|--ramdisk]  <file>		Input/Output Ramdisk filename(s)\n";
    print "  [-f|--fisdir]   <file>		Input/Output FIS directory filename\n";
    print "  [-t|--trailer]  <file>		Input/Output Trailer filename\n";
    print "  [-m|--macaddr]  <MAC>		Set the MAC address in RedBoot\n";
    print "  [-l|--payload]  <file>		Input/Output last block payload\n";

    # TODO: document --ramdisk syntax

    exit 1;
}

# Go through the partition options, and set the names and files in @partitions
if (defined $redboot) { map { ($_->{'name'} eq 'RedBoot') 	&& ($_->{'file'} = $redboot); } @partitions; }
if (defined $kernel)  { map { ($_->{'name'} eq 'Kernel')  	&& ($_->{'file'} = $kernel);  } @partitions; }
if (defined $sysconf) { map { ($_->{'name'} eq 'SysConf') 	&& ($_->{'file'} = $sysconf); } @partitions; }
if (defined $fisdir)  { map { ($_->{'name'} eq 'FIS directory') && ($_->{'file'} = $fisdir);  } @partitions; }
if (defined $trailer) { map { ($_->{'name'} eq 'Trailer')       && ($_->{'file'} = $trailer); } @partitions; }
if (defined $payload) { map { ($_->{'name'} eq 'FIS directory') && ($_->{'payload'} = $payload); } @partitions; }
if (defined $ramdisk) {

    # A single filename is used for the ramdisk filename
    if ($ramdisk !~ m/[:,]/) {
	map { ($_->{'name'} eq 'Ramdisk') && ($_->{'file'} = $ramdisk); } @partitions;
    }

    # otherwise, it's a list of name:file mappings
    else {
	my @mappings = split(',', $ramdisk);

	# Replace the Ramdisk entry with the new mappings
	splice(@partitions, 3, 1, map {

	    # Preserve the information from the ramdisk entry
	    my %entry = %{$partitions[3]};

	    # Parse the mapping
	    ($_ =~ m/^([^:]+):([^:]+)(:([^:]+))?$/) or die "Invalid syntax in --ramdisk\n";
	    $entry{'name'} = $1; $entry{'file'} = $2; my $size = $4;

	    # If the mapping is not for the ramdisk, then undefine its attributes
	    if ($entry{'name'} ne 'Ramdisk') {
		$entry{'offset'} = undef;
		$entry{'size'} = undef;
		$entry{'data'} = undef;
	    }

	    # Support specification of the number of blocks for empty jffs2
	    if ($entry{'file'} =~ m/^[0-9]+$/) {
		$size = $entry{'file'};
		$entry{'file'} = undef;
	    }

	    # If the user has specified a size, then respect their wishes
	    if (defined $size) {
		my($block_size) = 0x00020000;
		$entry{'size'} = $size * $block_size;
	    }

	    \%entry;

	} @mappings);
    }
}

# Read in the firmware image
if ($input) {
    my $result = readInFirmware($input, \@partitions);
}

# Unpack the firmware if requested
if ($unpack) {
#    map {
#	($_->{'name'} eq 'FIS directory') and @partitions = checkPartitionTable($_->{'data'});
#    } @partitions;

    writeOutFirmwareParts(@partitions);

}

# Undefine the ramdisk size - it must be calculated for packing
map {
    ($_->{'name'} eq "Ramdisk") && ($_->{'size'} = undef);
} @partitions;

# Pack the firmware if requested
if ($pack) {

    my $result = readInFirmwareParts(@partitions);

    if ($debug) {
	print "after readInFirmwareParts():\n";
	printPartitions(@partitions);
	map {
	    ($_->{'name'} eq 'RedBoot') && (printRedbootTrailer($_->{'data'}));
	} @partitions;
    }
    
    layoutPartitions(@partitions);

    if ($debug) {
	print "after layoutPartitions():\n";
	printPartitions(@partitions);
    }
    
    buildPartitionTable(@partitions);

    if ($debug) {
	print "after buildPartitionTable():\n";
	printPartitions(@partitions);

	my($lastblock);
	map {
	    if($_->{'name'} eq 'FIS directory'){
		$lastblock = $_->{'data'};
	    }
	} @partitions;

	print "checkPartitionTable():\n";
	checkPartitionTable($lastblock);
    }
    
    die "Output filename must be specified\n" unless defined $output;

    writeOutFirmware($output, @partitions);

}

exit 0;
