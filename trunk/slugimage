#!/usr/bin/perl
#
# SlugImage : manipulate NSLU2 firmware images
#             initial version: Dwayne (jacques) Fontenot Nov-11-2004
#

use strict;
use warnings;

use Getopt::Long;

sub ffPad {
    my($data,$total_len) = @_;

    my($pad_char) = pack("C",0xff);
    my($pad_len) = $total_len - length($data);

    return $data . $pad_char x $pad_len;
}

sub ramdiskPaddedSize {
    my($ramdisk_len) = @_;

    my($block_size) = 0x00020000;
    use integer;
    return ($ramdisk_len / $block_size) * $block_size + $block_size;
}

sub flashdiskPaddedSize {
    my($ramdisk_len) = @_;

    return 0x00680000 - ramdiskPaddedSize($ramdisk_len);
}

sub paddedSize {
    my($data_len) = @_;

    my($block_size) = 0x00020000;
    use integer;
    return ($data_len / $block_size) * $block_size + $block_size;
}

sub jffs2Block {
    return ffPad(pack("N3", 0x19852003, 0x0000000c, 0xf060dc98), 0x00020000);
}

sub partitionEntry {
    my($name, $flash_base, $size) = @_;

    my($zero_long) = 0x0000;

    return pack("a16N5x212N2",$name,$flash_base,$zero_long,$size,$zero_long,$zero_long,$zero_long,$zero_long);
}

sub newpartitionTable {
    my(@partitions) = @_;

    my $partition_data = "";

    print "---------------------------\n";

    map {

	for my $field (sort keys %{$_}){
	    print $field,'=>',$_->{$field},"\n";
	}
	
	$partition_data .= partitionEntry($_->{'name'}, $_->{'offset'}, $_->{'size'});

    } @partitions;

    print "---------------------------\n";
    return $partition_data;
}

sub trailerData {
    my($product_id)       = 0x0001;
    my($protocol_id)      = 0x0000;
    my($firmware_version) = 0x2325;
    my($unknown1)         = 0x90f7;
    my($magic_number)     = 'eRcOmM';
    my($unknown2)         = 0x00b9;

    return pack("n4a6n",$product_id,$protocol_id,$firmware_version,$unknown1,$magic_number,$unknown2);
}

sub lastBlock {
    my($ramdisk_len) = @_;

    my($block_size)      = 0x00020000;
    my($trailer_data)    = trailerData();

    return ffPad(partitionTable($ramdisk_len), $block_size - length($trailer_data)) . $trailer_data;
}

# layoutPartitions : this function must be ugly - it needs to verify RedBoot, SysConf, Kernel, Ramdisk, and
#     FIS directory partitions exist, are in the correct order, and do not have more data than can fit in
#     their lengths (fixed for all but Ramdisk, which has a minimum length of one block).
#     If Rootdisk and/or Userdisk exist, it must also verify that their block padded lengths are not
#     too great for the available space.
# input : a reference to an array of hashes with only name and data populated
# output: same reference with start and size (partition not data) also populated. this populated structure
#         can then be passed to newpartitionTable() to generate the actual partition table data
sub layoutPartitions {
    my($partitions) = @_;

    my($blocksize)     = 0x00020000;
    my($flash_start)   = 0x50000000;
    my($flash_len)     = 0x00800000;

    my($redboot_start) = 0x00000000 + $flash_start;
    my($redboot_len)   = 0x00040000;
    my($sysconf_start) = $redboot_start + $redboot_len;
    my($sysconf_len)   = 0x00020000;
    my($kernel_start)  = $sysconf_start + $sysconf_len;
    my($kernel_len)    = 0x00100000;
    my($ramdisk_start) = $kernel_start + $kernel_len;

    my($lastblock_start) = $flash_start + $flash_len - $blocksize;
    my($lastblock_len)   = $blocksize;

    # template codifies partition order and start and/or size values when they are fixed
    my(@template) = ({'name'=>'RedBoot', 'start'=>$redboot_start, 'size'=>$redboot_len},
		     {'name'=>'SysConf', 'start'=>$sysconf_start, 'size'=>$sysconf_len},
		     {'name'=>'Kernel',  'start'=>$kernel_start,  'size'=>$kernel_len},
		     {'name'=>'Ramdisk', 'start'=>$ramdisk_start},
		     {'name'=>'Rootdisk'},
		     {'name'=>'Userdisk'},
		     {'name'=>'FIS directory', 'start'=>$lastblock_start, 'size'=>$lastblock_len});

    #
    # here we go through the $partitions array ref and fill in all the values
    #

    return $partitions;
}

sub readInFirmware {
    my($filename, @partitions) = @_;

    my($firmware_buf);
    my($total_length)   = 0x800000;

    open FILE,$filename or die "can't find firmware image $filename: $!\n";

    read FILE,$firmware_buf,$total_length or die "can't read $total_length bytes from file $filename: $!\n";

    # Read the parts of the firmware file into the partitions table.
    map {

	# Grab the whole partition, using the maximum size.
	$_->{'data'} = substr($firmware_buf, $_->{'offset'}, $_->{'size'});

	# For those partitions which can be smaller, read the length and truncate the data.
	if (($_->{'name'} eq 'Kernel') or ($_->{'name'} eq 'Ramdisk')) {
	    $_->{'size'} = unpack("N", $_->{'data'});
	    $_->{'data'} = substr($_->{'data'}, 16, $_->{'size'});
	}

	print $_->{'name'}, " is ", length($_->{'data'}), " bytes long\n";

    } @partitions;

    return;
}

sub writeOutFirmwareParts {
    my(@partitions) = @_;

    # Read the parts of the firmware file into the partitions table.
    map {

	if (defined $_->{'data'}) {
	    writeOut($_->{'data'}, $_->{'file'});
	}

    } @partitions;

    return;
}

sub readInFirmwareParts {
    my(%parts) = ('RedBoot'=>'','SysConf'=>'','Kernel'=>'','Ramdisk'=>'','Flashdisk'=>'');

    undef $/; # we want to slurp

    foreach(keys %parts){
	open FILE,$_ or die "can't find firmware part $_: $!\n"; # should not die here
	$parts{$_} = <FILE>;
	print length($parts{$_}),"\n";
    }

    return($parts{'RedBoot'},$parts{'SysConf'},$parts{'Kernel'},$parts{'Ramdisk'},$parts{'Flashdisk'});
}

sub packImage {
    my($redboot_buf, $sysconf_buf, $kernel_buf, $ramdisk_buf, $flashdisk_buf) = @_;

    my($ramdisk_len) = length($ramdisk_buf);

    my($kernel_header)  = pack("N4",length($kernel_buf));
    my($ramdisk_header) = pack("N4",$ramdisk_len);

    my($ramdisk_padded_size) = ramdiskPaddedSize($ramdisk_len);

    return $redboot_buf . $sysconf_buf . ffPad($kernel_header . $kernel_buf, 0x100000) .
	ffPad($ramdisk_header . $ramdisk_buf, $ramdisk_padded_size) .
	ffPad($flashdisk_buf, flashdiskPaddedSize($ramdisk_len)) . lastBlock(length($ramdisk_buf));
}

sub writeOut {
    my($data, $filename) = @_;

    open FILE,">$filename" or die "can't open file $filename: $!\n";

    if(defined($data)){ print FILE $data;}

    close FILE;
}

sub defaultPartitions {

    return ({'name'=>'RedBoot',      'file'=>'Redboot',   'offset'=>0x00000000,'size'=>0x00040000,'data'=>'abcd'},
	    {'name'=>'SysConf',      'file'=>'SysConf',   'offset'=>0x00040000,'size'=>0x00020000,'data'=>'efgh'},
	    {'name'=>'Kernel',       'file'=>'vmlinuz',   'offset'=>0x00060000,'size'=>0x00100000,'data'=>'ijkl'},
	    {'name'=>'Ramdisk',      'file'=>'ramdisk.gz','offset'=>0x00160000,'size'=>0x006a0000,'data'=>'mnop'},
#           {'name'=>'Rootdisk',     'offset'=>0x00180000,'size'=>0x00100000,'data'=>'qrst'},
#           {'name'=>'Userdisk',     'offset'=>0x00280000,'size'=>0x00560000,'data'=>'uvwx'},
	    {'name'=>'FIS directory','file'=>'SlugTail',  'offset'=>0x007e0000,'size'=>0x00020000,'data'=>'yz12'},
	    );

}

#
# flow should go something like this:
# call @partitions = defaultPartitions(), populate filenames with command line args
# pass \@partitions to some func which reads the files and populates the data values
# pass \@partitions to layoutPartitions() to get fully populated (start and size values)
# some func, possibly layoutPartitions() needs to call ffPad() on the various partition data
# with the correct size value (which should have been calculated by layoutPartitions() with the
# help of fixed partition lengths and for variable length partitions, paddedSize()
# then write out the image, somewhere in there passing \@partitions to lastBlock() which in turn
# passes it to newpartitionTable (which should be renamed to partitionTable and replace it)
#

my(@partitions) = defaultPartitions();

my($pack, $unpack, $image, $redboot, $kernel, $sysconf, $ramdisk, $trailer, $macaddr, $debug);

my $result = GetOptions("p|pack"      => \$pack,
			"u|unpack"    => \$unpack,
			"i|image=s"   => \$image,
			"r|redboot=s" => \$redboot,
			"k|kernel=s"  => \$kernel,
			"s|sysconf=s" => \$sysconf,
			"r|ramdisk=s" => \$ramdisk,
			"t|trailer=s" => \$trailer,
			"m|macaddr=s" => \$macaddr,
			"d|debug"     => \$debug,
			);

# Go through the partition options, and set the names and files in @partitions

if (defined $redboot) {
    map { ($_->{'name'} eq 'RedBoot') && ($_->{'file'} = $redboot); } @partitions;
}

if (defined $kernel) {
    map { ($_->{'name'} eq 'Kernel') && ($_->{'file'} = $kernel); } @partitions;
}

if (defined $sysconf) {
    map { ($_->{'name'} eq 'SysConf') && ($_->{'file'} = $sysconf); } @partitions;
}

if (defined $ramdisk) {
    map { ($_->{'name'} eq 'Ramdisk') && ($_->{'file'} = $ramdisk); } @partitions;
}

# Print out the partition table filenames
if ($debug) {
    map { if (defined $_->{'file'}) { print $_->{'name'}, " :\t", $_->{'file'}, "\n"; }; } @partitions;
}

if ($unpack) {

    # TODO: instead of returning the _buf variables, put the data in @partitions
    my $result = readInFirmware($image, @partitions);

    # print "there is space for a ",flashdiskPaddedSize(length($ramdisk_buf))," byte Flashdisk partition\n";

    writeOutFirmwareParts(@partitions);

}

if ($debug) {

    # TODO: instead of returning the _buf variables, put the data in @partitions
    my ($redboot_buf, $sysconf_buf, $kernel_buf, $ramdisk_buf, $flashdisk_buf) = readInFirmwareParts();

    writeOut($redboot_buf,   'RedBoot.1');
    writeOut($sysconf_buf,   'SysConf.1');
    writeOut($kernel_buf,    'Kernel.1');
    writeOut($ramdisk_buf,   'Ramdisk.1');
    writeOut($flashdisk_buf, 'Flashdisk.1');

    my($jffs2_block) = jffs2Block();

    writeOut($jffs2_block x 24, 'Flashdisk.myjffs2');
}

if ($pack) {

    my ($redboot_buf, $sysconf_buf, $kernel_buf, $ramdisk_buf, $flashdisk_buf) = readInFirmwareParts();

    newpartitionTable(\@partitions);

    # TODO: pass @partitions to packImage
    writeOut(packImage($redboot_buf, $sysconf_buf, $kernel_buf, $ramdisk_buf, $flashdisk_buf), 'FirmwareImage');
}
