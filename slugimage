#!/usr/bin/perl
#
# SlugImage : manipulate NSLU2 firmware images
#             initial version: Dwayne (jacques) Fontenot Nov-11-2004
#

use strict;
use warnings;

use Getopt::Long;

sub padBytes {
    my($data,$total_len) = @_;

    my($pad_char) = pack("C",0x00);
    my($pad_len) = $total_len - length($data);

    return $data . ($pad_char x $pad_len);
}

sub paddedSize {
    my($data_len) = @_;

    my($block_size) = 0x00020000;
    use integer;
    return (($data_len - 1) / $block_size) * $block_size + $block_size;
}

sub jffs2Block {
    return padBytes(pack("N3", 0x19852003, 0x0000000c, 0xf060dc98), 0x00020000);
}

sub writeOut {
    my($data, $filename) = @_;

    open FILE,">$filename" or die "can't open file $filename: $!\n";

    if(defined($data)){ print FILE $data;}

    close FILE or die "can't close file $filename: $!\n";
}

sub partitionEntry {
    my($name, $flash_base, $size) = @_;

    my($zero_long) = 0x0000;

    return pack("a16N5x212N2",$name,$flash_base,$zero_long,$size,$zero_long,$zero_long,$zero_long,$zero_long);
}

sub buildPartitionTable {
    my(@partitions) = @_;

    my $partition_data = "";

    map {

	$partition_data .= partitionEntry($_->{'name'}, $_->{'offset'}, $_->{'size'});

	# If this is the FIS directory, then write the partition table data into it.
	if ($_->{'name'} eq "FIS directory") {
	    $_->{'data'} = $partition_data;
	}

    } @partitions;

    return;
}

sub trailerData {
    my($product_id)       = 0x0001;
    my($protocol_id)      = 0x0000;
    my($firmware_version) = 0x2325;
    my($unknown1)         = 0x90f7;
    my($magic_number)     = 'eRcOmM';
    my($unknown2)         = 0x00b9;

    return pack("n4a6n",$product_id,$protocol_id,$firmware_version,$unknown1,$magic_number,$unknown2);
}

# layoutPartitions : this function must be ugly - it needs to verify RedBoot, SysConf, Kernel, Ramdisk, and
#     FIS directory partitions exist, are in the correct order, and do not have more data than can fit in
#     their lengths (fixed for all but Ramdisk, which has a minimum length of one block).
#     If Rootdisk and/or Userdisk exist, it must also verify that their block padded lengths are not
#     too great for the available space.
# input : an array of hashes, some of which are populated with data
# output: same reference with start and size (partition not data) also populated. this populated structure
#         can then be passed to buildPartitionTable() to generate the actual partition table data
sub layoutPartitions {
    my(@partitions) = @_;

    my($flash_start)   = 0x50000000;
    my($flash_len)     = 0x00800000;

    #
    # here we go through the $partitions array ref and fill in all the values
    #

    my $pointer = $flash_start;

    map {

	if (defined $_->{'size'}) {

	    # Determine the start and offset of the current partition.
	    if (defined $_->{'offset'}) {
		$_->{'start'} = $flash_start + $_->{'offset'};
		print("Allocated <", $_->{'name'}, "> from ", sprintf("0x%08X", $_->{'start'}),
		      " to ", sprintf("0x%08X", $_->{'start'} + $_->{'size'}), "\n");
	    }
	    else {
		$_->{'start'} = $pointer;
		$_->{'offset'} = $_->{'start'} - $flash_start;
		print("Allocated <", $_->{'name'}, "> from ", sprintf("0x%08X", $_->{'start'}),
		      " to ", sprintf("0x%08X", $_->{'start'} + $_->{'size'}), "\n");
	    }

	    if (($_->{'start'} + $_->{'size'}) > ($flash_start + $flash_len)) {
		die "ran out of flash space during ", $_->{'name'}, "\n";
	    }

	    $pointer = $_->{'start'} + paddedSize($_->{'size'});

	}
	else {
	    print "Skipping ", $_->{'name'}, "\n";
	}

    } @partitions;

    return;
}

sub readInFirmware {
    my($filename, @partitions) = @_;

    my($firmware_buf);
    my($total_length)   = 0x800000;

    open FILE,$filename or die "can't find firmware image $filename: $!\n";

    read FILE,$firmware_buf,$total_length or die "can't read $total_length bytes from file $filename: $!\n";

    # Read the parts of the firmware file into the partitions table.
    map {

	if (defined $_->{'file'} and defined $_->{'offset'} and defined $_->{'size'}) {

	    # Grab the whole partition, using the maximum size.
	    $_->{'data'} = substr($firmware_buf, $_->{'offset'}, $_->{'size'});

	    # For those partitions which can be smaller, read the length and truncate the data.
	    if (($_->{'name'} eq 'Kernel') or ($_->{'name'} eq 'Ramdisk')) {
		$_->{'size'} = unpack("N", $_->{'data'});
		$_->{'data'} = substr($_->{'data'}, 16, $_->{'size'});
	    }

	    print("Read ", sprintf("0x%08X", length($_->{'data'})), " bytes from \"",
		  $filename, "\" into <", $_->{'name'}, ">\n");
	}

    } @partitions;

    close FILE or die "can't close $filename: $!\n";

    return;
}

sub writeOutFirmwareParts {
    my(@partitions) = @_;

    # Read the parts of the firmware file into the partitions table.
    map {

	if (defined $_->{'data'}) {
	    writeOut($_->{'data'}, $_->{'file'});
	    print("Wrote ", sprintf("0x%08X", length($_->{'data'})), " bytes from <",
		  $_->{'name'}, "> into \"", $_->{'file'}, "\"\n");

	}

    } @partitions;

    return;
}

sub readInFirmwareParts {
    my(@partitions) = (@_);

    undef $/; # we want to slurp

    map {

	my $file = $_->{'file'};
	if (defined $file) {
	    open FILE,$file or die "can't find firmware part $file: $!\n";
	    $_->{'data'} = <FILE>;
	    $_->{'size'} = length($_->{'data'});
	    print("Read ", sprintf("0x%08X", length($_->{'data'})), " bytes from \"",
		  $_->{'file'}, "\" into <", $_->{'name'}, ">\n");
	}

    } @partitions;

    return;
}

sub writeImage {
    my($filename, @partitions) = @_;

    my $image_buf = "";

    map {

	my $pointer = length($image_buf);

	if ($_->{'offset'} > $pointer) {
	    $image_buf .= padBytes("", $_->{'offset'} - $pointer);
	    my($block_size) = 0x00020000;
	    use integer;
	    my($blocks) = ((length($image_buf) - $pointer) / $block_size);
	    print("Padded ", sprintf("%d", $blocks), " blocks before <",
		  $_->{'name'}, "> in \"", $filename, "\"\n");
	    $pointer = length($image_buf);
	}
	elsif ($_->{'offset'} < $pointer) {
	    $image_buf = substr($image_buf, 0, $_->{'offset'});
	    print("Rewound ", sprintf("0x%08X", $pointer - $_->{'offset'}), " bytes before <",
		  $_->{'name'}, "> in \"", $filename, "\"\n");
	    $pointer = length($image_buf);
	}

	if ($_->{'name'} eq "Kernel") {
	    $_->{'size'} = 0x100000;
	    $image_buf .= padBytes(pack("N4",length($_->{'data'})).$_->{'data'},
				$_->{'size'});
	}
	elsif ($_->{'name'} eq "Ramdisk") {
	    $image_buf .= padBytes(pack("N4",length($_->{'data'})).$_->{'data'},
				paddedSize($_->{'size'}));
	}
	elsif ($_->{'name'} eq "Trailer") {
	    $image_buf .= $_->{'data'};
	}
	else {
	    $image_buf .= padBytes($_->{'data'}, paddedSize(length($_->{'data'})));
	}

	print("Wrote ", sprintf("0x%08X", length($image_buf) - $pointer), " bytes from <",
	      $_->{'name'}, "> into \"", $filename, "\"\n");

    } @partitions;

    writeOut($image_buf, $filename);

    return;
}


sub defaultPartitions {

    # Note that other routines make assumptions that this table will stay in the current order, with
    # new partitions only being added where the current Ramdisk partition exists.
    # In particular, the Ramdisk partition must stay at index 3, and the partition at the end of the
    # Ramdisk/Rootdisk/Userdis partitions must stay at index -2.

    return ({'name'=>'RedBoot',      'file'=>'Redboot',   'offset'=>0x00000000,'size'=>0x00040000,'data'=>undef},
	    {'name'=>'SysConf',      'file'=>'SysConf',   'offset'=>0x00040000,'size'=>0x00020000,'data'=>undef},
	    {'name'=>'Kernel',       'file'=>'vmlinuz',   'offset'=>0x00060000,'size'=>0x00100000,'data'=>undef},
	    {'name'=>'Ramdisk',      'file'=>'ramdisk.gz','offset'=>0x00160000,'size'=>0x006a0000,'data'=>undef},
	    {'name'=>'FIS directory','file'=>undef,       'offset'=>0x007e0000,'size'=>0x00020000,'data'=>undef},
	    {'name'=>'Trailer',      'file'=>'Trailer',   'offset'=>0x007ffff0,'size'=>0x00000010,'data'=>undef},
	    );

}

#
# flow should go something like this:
# call @partitions = defaultPartitions(), populate filenames with command line args
# pass \@partitions to some func which reads the files and populates the data values
# pass \@partitions to layoutPartitions() to get fully populated (start and size values)
# some func, possibly layoutPartitions() needs to call padBytes() on the various partition data
# with the correct size value (which should have been calculated by layoutPartitions() with the
# help of fixed partition lengths and for variable length partitions, paddedSize()
# then write out the image, somewhere in there passing \@partitions to lastBlock() which in turn
# passes it to buildPartitionTable (which should be renamed to partitionTable and replace it)
#

my(@partitions) = defaultPartitions();

my($unpack, $pack, $jffs2gen, $input, $output, $redboot, $kernel, $sysconf, $ramdisk, $trailer, $macaddr, $debug);

if (!GetOptions("d|debug"      => \$debug,
		"u|unpack"     => \$unpack,
		"p|pack"       => \$pack,
		"j|jffs2gen=i" => \$jffs2gen,
		"i|input=s"    => \$input,
		"o|output=s"   => \$output,
		"b|redboot=s"  => \$redboot,
		"k|kernel=s"   => \$kernel,
		"s|sysconf=s"  => \$sysconf,
		"r|ramdisk=s"  => \$ramdisk,
		"t|trailer=s"  => \$trailer,
		"m|macaddr=s"  => \$macaddr,
		) or (not defined $jffs2gen and not defined $pack and not defined $unpack)) {
    print "Usage: slugimage <options>\n";
    print "\n";
    print "  [-d|--debug]			Turn on debugging output\n";
    print "  [-u|--unpack]			Unpack a firmware image\n";
    print "  [-p|--pack]			Pack a firmware image\n";
    print "  [-j|--jffs2gen] <size>		Generate an empty JFFS2 image\n";
    print "  [-i|--input]    <file>		Input firmware image filename\n";
    print "  [-o|--output]   <file>		Output firmware image filename\n";
    print "  [-b|--redboot]  <file>		Input/Output RedBoot filename\n";
    print "  [-k|--kernel]   <file>		Input/Ouptut Kernel filename\n";
    print "  [-s|--sysconf]  <file>		Input/Output SysConf filename\n";
    print "  [-r|--ramdisk]  <file>		Input/Output Ramdisk filename(s)\n";
    print "  [-t|--trailer]  <file>		Input/Output Trailer filename\n";
    print "  [-m|--macaddr]  <MAC>		Set the MAC address in RedBoot\n";

    exit 1;
}

if ($jffs2gen) {

    my($jffs2_block) = jffs2Block();

    writeOut($jffs2_block x $jffs2gen, $output);
    print "Wrote $jffs2gen blocks to \"$output\"\n";

    exit 0;
}


# Go through the partition options, and set the names and files in @partitions
if (defined $redboot) { map { ($_->{'name'} eq 'RedBoot') && ($_->{'file'} = $redboot); } @partitions; }
if (defined $kernel)  { map { ($_->{'name'} eq 'Kernel')  && ($_->{'file'} = $kernel);  } @partitions; }
if (defined $sysconf) { map { ($_->{'name'} eq 'SysConf') && ($_->{'file'} = $sysconf); } @partitions; }
if (defined $trailer) { map { ($_->{'name'} eq 'Trailer') && ($_->{'file'} = $trailer); } @partitions; }
if (defined $ramdisk) {

    # A single filename is used for the ramdisk filename
    if ($ramdisk !~ m/[:,]/) {
	map { ($_->{'name'} eq 'Ramdisk') && ($_->{'file'} = $ramdisk); } @partitions;
    }

    # otherwise, it's a list of name:file mappings
    else {
	my @mappings = split(',', $ramdisk);

	# Replace the Ramdisk entry with the new mappings
	splice(@partitions, 3, 1, map {

	    # Preserve the information from the ramdisk entry
	    my %entry = %{$partitions[3]};

	    # Parse the mapping
	    ($_ =~ m/^([^:]+):([^:]+)$/) or die "invalid syntax in --ramdisk\n";
	    $entry{'name'} = $1; $entry{'file'} = $2;

	    # If the mapping is not for the ramdisk, then undefine its attributes
	    if ($entry{'name'} ne 'Ramdisk') {
		$entry{'offset'} = undef;
		$entry{'size'} = undef;
		$entry{'data'} = undef;
	    }
	    \%entry;

	} @mappings);
    }
}

# Unpack the firmware if requested
if ($unpack) {

    my $result = readInFirmware($input, @partitions);

    writeOutFirmwareParts(@partitions);

}

# Pack the firmware if requested
if ($pack) {

    my $result = readInFirmwareParts(@partitions);

    layoutPartitions(@partitions);

    buildPartitionTable(@partitions);

    writeImage($output, @partitions);
}

exit 0;
